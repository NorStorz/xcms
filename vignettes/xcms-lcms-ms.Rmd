---
title: "LC-MS/MS data analysis with xcms"
package: xcms
output:
  BiocStyle::html_document:
    toc_float: true
    includes:
      in_header: xcms-lcms-ms.bioschemas.html
vignette: >
  %\VignetteIndexEntry{LC-MS/MS data analysis with xcms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcms,msdata,BiocStyle,magrittr,pander,Spectra,MsBackendMgf}
  %\VignettePackage{xcms}
  %\VignetteKeywords{mass spectrometry, metabolomics}
bibliography: references.bib
csl: biomed-central.csl
---

```{r biocstyle, echo = FALSE, results = "asis"}
BiocStyle::markdown()
```

**Package**: `r Biocpkg("xcms")`<br />
**Authors**: Johannes Rainer, Michael Witting<br />
**Modified**: `r file.info("xcms-lcms-ms.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r init, message = FALSE, echo = FALSE, results = "hide"}
## Silently loading all packages
library(BiocStyle)
library(xcms)
library(pander)
register(SerialParam())

```

# Introduction

Metabolite identification is an important step in non-targeted metabolomics and
requires different steps. One involves the use of tandem mass spectrometry to
generate fragmentation spectra of detected metabolites (LC-MS/MS), which are
then compared to fragmentation spectra of known metabolites. Different
approaches exist for the generation of these fragmentation spectra, whereas the
most used is data dependent acquisition (DDA) also known as the top-n method. In
this method the top N most intense m/z values from a MS1 scan are selected for
fragmentation in the next N scans before the cycle starts again. This method
allows to generate clean MS2 fragmentation spectra on the fly during acquisition
without the need for further experiments, but suffers from poor coverage of the
detected metabolites (since only a limited number of ions are fragmented).

Data independent approaches (DIA) like Bruker bbCID, Agilent AllIons or Waters
MSe don't use such a preselection, but rather fragment all detected molecules at
once. They are using alternating schemes with scan of low and high collision
energy to collect MS1 and MS2 data. Using this approach, there is no problem in
coverage, but the relation between the precursor and fragment masses is lost
leading to chimeric spectra. Sequential Window Acquisition of all Theoretical
Mass Spectra (or SWATH [@Ludwig:2018hv]) combines both approaches through a
middle-way approach. There is no precursor selection and acquisition is
independent of acquired data, but rather than isolating all precusors at once,
defined windows (i.e. ranges of m/z values) are used and scanned. This reduces
the overlap of fragment spectra while still keeping a high coverage.

This document showcases the analysis of two small LC-MS/MS data sets using
`r Biocpkg("xcms")`. The data files used are reversed-phase LC-MS/MS runs from the
Agilent Pesticide mix obtained from a Sciex 6600 Triple ToF operated in SWATH
acquisition mode. For comparison a DDA file from the same sample is included.

# Analysis of DDA data

Below we load the example DDA data set using the `readMSData` function from the
`r Biocpkg("MSnbase")` package.

```{r load-dda-data, message = FALSE}
library(xcms)

dda_file <- system.file("TripleTOF-SWATH/PestMix1_DDA.mzML",
                        package = "msdata")
dda_data <- readMSData(dda_file, mode = "onDisk")
```

```{r subset-dda, echo = FALSE, message = FALSE, eval = TRUE}
#' Silently sub-setting the object to speed-up analysis
dda_data <- filterRt(dda_data, rt = c(200, 600))
```

The variable `dda_data` contains now all MS1 and MS2 spectra from the specified
mzML file. The number of spectra for each MS level is listed below.

```{r dda-table-mslevel}
table(msLevel(dda_data))
```

For the MS2 spectra we can get the m/z of the precursor ion with the
`precursorMz` function. Below we first filter the data set by MS level, extract
the precursor m/z and call `head` to just show the first 6 elements. For easier
readability we use the forward pipe operator `%>%` from the `magrittr` package.

```{r precursor}
library(magrittr)

dda_data %>%
    filterMsLevel(2L) %>%
    precursorMz() %>%
    head()
```

With the `precursorIntensity` function it is also possible to extract the
intensity of the precursor ion.

```{r precursor-intensity}
dda_data %>%
    filterMsLevel(2L) %>%
    precursorIntensity() %>%
    head()
```

Some manufacturers (like Sciex for the present test data) don't define/export
the precursor intensity and thus either `NA` or `0` is reported. We can however
use the `estimatePrecursorIntensity` function to determine the precursor
intensity for a MS 2 spectrum based on the intensity of the respective ion in
the previous MS1 scan (note that with `method = "interpolation"` the precursor
intensity would be defined based on interpolation between the intensity in the
previous and subsequent MS1 scan). Below we estimate the precursor intensities,
on the full data (for MS1 spectra a `NA` value is reported)

```{r estimate-precursor}
prec_int <- estimatePrecursorIntensity(dda_data)
```

We next set the precursor intensity in the spectrum metadata of `dda_data`. So
that it can be extracted later with the `precursorIntensity` function.

```{r set-precursor-intensity}
fData(dda_data)$precursorIntensity <- prec_int

dda_data %>%
    filterMsLevel(2L) %>%
    precursorIntensity() %>%
    head()
```

Next we perform the chromatographic peak detection on the MS level 1 data with
the `findChromPeaks` method. Below we define the settings for a *centWave*-based
peak detection and perform the analysis.

```{r dda-find-chrom-peaks-ms1, message = FALSE}
cwp <- CentWaveParam(snthresh = 5, noise = 100, ppm = 10,
                     peakwidth = c(3, 30))
dda_data <- findChromPeaks(dda_data, param = cwp)
```

In total `r nrow(chromPeaks(dda_data))` peaks were identified in the present
data set.

The advantage of LC-MS/MS data is that (MS1) ions are fragmented and the
corresponding MS2 spectra measured. Thus, for some of the ions (identified as
MS1 chromatographic peaks) MS2 spectra are available. These can facilitate the
annotation of the respective MS1 chromatographic peaks (or MS1 features after a
correspondence analysis). Spectra for identified chromatographic peaks can be
extracted with the `chromPeakSpectra` method. MS2 spectra with their precursor
m/z and retention time within the rt and m/z range of the chromatographic peak
are returned. Parameter `return.type` allows to define in which format these are
returned. With `return.type = "List"` or `return.type = "Spectra"` the data is
represented by a `Spectra` object from the `r BiocStyle::Biocpkg("Spectra")`.

```{r dda-spectra, message = FALSE, eval = TRUE}
library(Spectra)
## requireNamespace("Spectra", quietly = TRUE)
dda_spectra <- chromPeakSpectra(
    dda_data, msLevel = 2L, return.type = "Spectra")
dda_spectra
```

By default `chromPeakSpectra` returns all spectra associated with a MS1
chromatographic peak, but parameter `method` allows to choose and return only
one spectrum per peak (have a look at the `?chromPeakSpectra` help page for more
details). Also, it would be possible to extract MS1 spectra for each peak by
specifying `msLevel = 1L` in the call above (e.g. to evaluate the full MS1
signal at the peak's apex position).

In the example above we selected to return the data as a `Spectra`
object. Spectra variables `"peak_id"` and `"peak_index"` contain the identifiers
and the index (in the `chromPeaks` matrix) of the chromatographic peaks the MS2
spectrum is associated with.

```{r peak_id, eval = TRUE}
dda_spectra$peak_id
```

Note also that with `return.type = "List"` a list parallel to the `chromPeaks`
matrix would be returned, i.e. each element in that list would contain the
spectra for the chromatographic peak with the same index. This data
representation might eventually simplify further processing.

We next use the MS2 information to aid in the annotation of a chromatographic
peak. As an example we use a chromatographic peak of an ion with an m/z of
304.1131 which we extract in the code block below.

```{r dda-ms2-example, message = FALSE, eval = TRUE}
ex_mz <- 304.1131
chromPeaks(dda_data, mz = ex_mz, ppm = 20)
```

A search of potential ions with a similar m/z in a reference database
(e.g. [Metlin](https://metlin.scripps.edu)) returned a large list of potential
hits, most with a very small ppm. For two of the hits,
[Flumazenil](https://en.wikipedia.org/wiki/Flumazenil) (Metlin ID 2724) and
[Fenamiphos](https://en.wikipedia.org/wiki/Fenamiphos) (Metlin ID 72445)
experimental MS2 spectra are available. Thus, we could match the MS2 spectrum
for the identified chromatographic peak against these to annotate our ion. Below
we extract all MS2 spectra that were associated with the candidate
chromatographic peak using the ID of the peak in the present data set.

```{r dda-ms2-get-ms2, message = FALSE, eval = TRUE}
ex_id <- rownames(chromPeaks(dda_data, mz = ex_mz, ppm = 20))
ex_spectra <- dda_spectra[dda_spectra$peak_id == ex_id]
ex_spectra
```

There are 5 MS2 spectra representing fragmentation of the ion(s) measured
in our candidate chromatographic peak. We next reduce this to a single MS2
spectrum using the `combineSpectra` method employing the `combinePeaks`
function to determine which peaks to keep in the resulting spectrum (have a look
at the `?combinePeaks` help page for details). Parameter `f` allows to specify
which spectra in the input object should be combined into one.

```{r dda-ms2-consensus, message = FALSE, eval = TRUE}
ex_spectrum <- Spectra::combineSpectra(ex_spectra, FUN = combinePeaks, ppm = 20,
                              peaks = "intersect", minProp = 0.8,
                              intensityFun = median, mzFun = median,
                              f = ex_spectra$peak_id)
ex_spectrum
```

Mass peaks from all input spectra with a difference in m/z smaller 20 ppm
(parameter `ppm`) were combined into one peak and the median m/z and intensity
is reported for these. Due to parameter `minProp = 0.8`, the resulting MS2
spectrum contains only peaks that were present in 80% of the input spectra.

A plot of this *consensus* spectrum is shown below.

```{r dda-ms2-consensus-plot, message = FALSE, fig.cap = "Consensus MS2 spectrum created from all measured MS2 spectra for ions of chromatographic peak CP53.", fig.width = 8, fig.height = 8, eval = TRUE}
plotSpectra(ex_spectrum)
```

We could now match the consensus spectrum against a database of MS2 spectra. In
our example we simply load MS2 spectra for the two compounds with matching m/z
exported from Metlin. For each of the compounds MS2 spectra created with
collision energies of 0V, 10V, 20V and 40V are available. Below we import the
respective data and plot our candidate spectrum against the MS2 spectra of
Flumanezil and Fenamiphos (from a collision energy of 20V). To import files in
MGF format we have to load the `MsBackendMgf` R package which adds MGF file
support to the `Spectra` package. This package can be installed with
`BiocManager::install("RforMassSpectrometry/MsBackendMgf")`.

Prior plotting we *normalize* our experimental spectra.

```{r normalize, eval = FALSE}
norm_fun <- function(z, ...) {
    z[, "intensity"] <- z[, "intensity"] /
        max(z[, "intensity"], na.rm = TRUE) * 100
    z
}
ex_spectrum <- addProcessing(ex_spectrum, FUN = norm_fun)
```

```{r dda-ms2-metlin-match, fig.cap = "Mirror plots for the candidate MS2 spectrum against Flumanezil (left) and Fenamiphos (right). The upper panel represents the candidate MS2 spectrum, the lower the target MS2 spectrum. Matching peaks are indicated with a dot.", fig.width = 12, fig.height = 6, eval = TRUE}
library(MsBackendMgf)
flumanezil <- Spectra(
    system.file("mgf/metlin-2724.mgf", package = "xcms"),
    source = MsBackendMgf())
fenamiphos <- Spectra(
    system.file("mgf/metlin-72445.mgf", package = "xcms"),
    source = MsBackendMgf())

par(mfrow = c(1, 2))
plotSpectraMirror(ex_spectrum, flumanezil[3], main = "against Flumanezil",
                  ppm = 40)
plotSpectraMirror(ex_spectrum, fenamiphos[3], main = "against Fenamiphos",
                  ppm = 40)
```

Our candidate spectrum matches Fenamiphos, thus, our example chromatographic
peak represents signal measured for this compound. In addition to plotting the
spectra, we can also calculate similarities between them with the
`compareSpectra` method (which uses by default the normalized dot-product to
calculate the similarity).

```{r dda-ms2-dotproduct, eval = TRUE}
Spectra::compareSpectra(ex_spectrum, flumanezil, ppm = 40)
Spectra::compareSpectra(ex_spectrum, fenamiphos, ppm = 40)
```

Clearly, the candidate spectrum does not match Flumanezil, while it has a high
similarity to Fenamiphos. While we performed here the MS2-based annotation on a
single chromatographic peak, this could be easily extended to the full list of
MS2 spectra (returned by `chromPeakSpectra`) for all chromatographic peaks in an
experiment. See also [here](https://jorainer.github.io/SpectraTutorials/).

In the present example we used only a single data file and we did thus not need
to perform a sample alignment and correspondence analysis. These tasks could
however be performed similarly to *plain* LC-MS data, retention times of
recorded MS2 spectra would however also be adjusted during alignment based on
the MS1 data. After correspondence analysis (peak grouping) MS2 spectra for
*features* can be extracted with the `featureSpectra` function which returns all
MS2 spectra associated with any chromatographic peak of a feature.

Note also that this workflow can be included into the *Feature-Based
Molecular Networking*
[FBMN](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/)
to match MS2 spectra against [GNPS](https://gnps.ucsd.edu/). See
[here](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-xcms3/)
for more details and examples.


# Outlook

Currently, spectra data representation, handling and processing is being
re-implemented as part of the
[RforMassSpectrometry](https://rformassspectrometry.org) initiative aiming at
increasing the performance of methods and simplifying their use. Thus, parts of
the workflow described here will be changed (improved) in future.

Along with these developments, improved matching strategies for larger data sets
will be implemented as well as functionality to compare `Spectra` directly to
reference MS2 spectra from public annotation resources (e.g. Massbank or
HMDB). See for example [here](https://jorainer.github.io/SpectraTutorials) for
more information.

Regarding SWATH data analysis, future development will involve improved
selection of the correct MS2 chromatographic peaks considering also correlation
with intensity values across several samples.

# Session information

```{r sessionInfo}
sessionInfo()
```

# References
