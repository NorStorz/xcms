---
title: "LC-MS feature grouping"
package: CompMetaboTools
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{LC-MS feature grouping}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcms,msdata,BiocStyle,faahKO,pheatmap,MsFeatures}
  %\VignettePackage{xcms}
  %\VignetteKeywords{mass spectrometry, metabolomics}
---

```{r biocstyle, echo = FALSE, results = "asis"}
BiocStyle::markdown()
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

**Package**: `r Biocpkg("xcms")`<br />
**Authors**: Johannes Rainer<br />
**Modified**: `r file.info("LC-MS-feature-grouping.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r init, results = "hide", echo = FALSE}
## Silently loading all packages
library(BiocStyle)
library(xcms)
register(SerialParam())

```

# Introduction

In a typical LC-MS-based metabolomics experiment compounds eluting from the
chromatography are first ionized before being measured by mass spectrometry
(MS). During the ionization different (multiple) ions can be generated from the
same compound which all will be measured by MS. In general, the resulting data
is then pre-processed to identify chromatographic peaks in the data and to group
these across samples in the correspondence analysis. The result are distinct
LC-MS features, characterized by their specific m/z and retention time
range. Different ions generated during ionization will be detected as different
features. To reduce data set complexity (and to aid in subsequent annotation
steps) it is advisable to group features which are supposedly representing
signal from the same original ion. This document describes functionality to aid
in this feature grouping step which are provided by this package.

General MS feature grouping concepts and functionality are provided by
Bioconductor's `r Biocpkg("MsFeatures")` package. Within `xcms` this
functionality is re-used and expanded to also allow feature grouping based on
similarity between the features' extracted ion chromatograms (EIC).


# LC-MS feature grouping

We demonstrate the feature grouping functionality on the simple toy data set
used also in the `r Biocpkg("xcms")` package and provided through the `faahKO`
package. This data set consists of samples from 4 mice with knock-out of the
fatty acid amide hydrolase (FAAH) and 4 wild type mice. Pre-processing of this
data set is described in detail in the *xcms* vignette of the `xcms`
package. Below we load all required packages and the result from this
pre-processing updating also the location of the respective raw data files on
the current machine.

```{r load-data}
library(xcms)
library(faahKO)
library(MsFeatures)

data("xdata")
## Update the path to the files for the local system
dirname(xdata) <- c(rep(system.file("cdf", "KO", package = "faahKO"), 4),
                    rep(system.file("cdf", "WT", package = "faahKO"), 4))
```

Before performing the feature grouping we inspect the result object. With
`featureDefinitions` we can extract the results from the correspondence
analysis.

```{r fdev}
featureDefinitions(xdata)
```

Each row in this data frame represents the definition of one feature, with its
average and range of m/z and retention time. Column `"peakidx"` provides the
index of each chromatographic peak which is assigned to the feature in the
`chromPeaks` matrix of the result object. The `featureValues` function allows to
extract *feature values*, i.e. a matrix with feature abundances, one row per
feature and columns representing the samples of the present data set.

Below we extract the feature values with and without *filled-in* peak
data. Without the gap-filled data only abundances from **detected**
chromatographic peaks are reported. In the gap-filled data, for samples in which
no chromatographic peak for a feature was detected, all signal from the m/z -
retention time range defined based on the detected chromatographic peaks was
integrated.

```{r filled-not-filled}
head(featureValues(xdata, filled = FALSE))
head(featureValues(xdata, filled = TRUE))
```

In total `r nrow(featureDefinitions(xdata))` features have been defined in the
present data set, many of which most likely represent signal from different ions
(adducts or isotopes) of the same compound. The aim of the grouping functions of
are now to define which features most likely come from the same original
compound. The feature grouping functions base on the following
assumptions/properties of LC-MS data:

- Features (ions) of the same compound should have similar retention time.
- The abundance of features (ions) of the same compound should have a similar
  pattern across samples, i.e. if a compound is highly concentrated in one
  sample and low in another, all ions from it should follow the same pattern.
- The peak shape of extracted ion chromatograms (EIC) of features of the same
  compound should be similar as it should follow the elution pattern of the
  original compound from the LC.

The main method to perform the feature grouping is called `groupFeatures` which
takes an `XCMSnExp` object (result object from the `xcms` pre-processing) as
input as well as a parameter object to chose the grouping algorithm and specify
its settings. `xcms` provides and supports the following grouping approaches:

- `SimilarRtimeParam`: perform an initial grouping based on similar retention
  time.
- `AbundanceSimilarityParam`: perform a feature grouping based on correlation
  of feature abundances (values) across samples.
- `EicSimilarityParam`: perform a feature grouping based on correlation of
  EICs.

Calling `groupFeatures` on an `xcms` result object will perform a feature
grouping assigning each feature in the data set to a *feature group*. These
feature groups are stored as an additional column called `"feature_group"` in
the `featureDefinition` data frame of the result object and can be accessed with
the `featureGroups` function. Any subsequent `groupFeature` call will
*sub-group* (refine) the identified feature groups further. It is thus possible
to use a single grouping approach, or to combine multiple of them to generate
the desired feature grouping. While the individual feature grouping algorithms
can be called in any order, it is advisable to use the `EicSimilarityParam` as
last refinement step, because it is the computationally most expensive one,
especially if applied to a result object without any pre-defined feature groups
or if the feature groups are very large. In the subsequent sections we will
apply the various feature grouping approaches subsequently.

Note also that we perform here a grouping of all defined features, but it would
also be possible to *just* group a subset of interesting features (e.g. features
found significant by a statistical analysis of the data set). This is described
in the last section of this vignette.
